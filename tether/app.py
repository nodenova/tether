"""Bootstrap: wires all components together."""

from __future__ import annotations

import json
import logging
import logging.handlers
from pathlib import Path
from typing import TYPE_CHECKING

import structlog

from tether.agents.claude_code import ClaudeCodeAgent
from tether.core.config import TetherConfig, ensure_tether_dir
from tether.core.engine import Engine
from tether.core.events import EventBus
from tether.core.interactions import InteractionCoordinator
from tether.core.safety.approvals import ApprovalCoordinator
from tether.core.safety.audit import AuditLogger
from tether.core.safety.policy import PolicyEngine
from tether.core.safety.sandbox import SandboxEnforcer
from tether.core.session import SessionManager
from tether.git.handler import GitCommandHandler
from tether.git.service import GitService
from tether.middleware.auth import AuthMiddleware
from tether.middleware.base import MiddlewareChain
from tether.middleware.rate_limit import RateLimitMiddleware
from tether.plugins.builtin.audit_plugin import AuditPlugin
from tether.plugins.builtin.browser_tools import BrowserToolsPlugin
from tether.plugins.builtin.merge_resolver import MergeResolverPlugin
from tether.plugins.builtin.test_runner import TestRunnerPlugin
from tether.plugins.registry import PluginRegistry
from tether.storage.memory import MemorySessionStore
from tether.storage.sqlite import SqliteSessionStore

if TYPE_CHECKING:
    from tether.connectors.base import BaseConnector
    from tether.plugins.base import TetherPlugin
    from tether.storage.base import MessageStore, SessionStore

logger = structlog.get_logger()


def switch_log_dir(new_dir: Path, config: TetherConfig) -> None:
    """Move the rotating file log handler to a new directory."""
    new_dir.mkdir(parents=True, exist_ok=True)
    root = logging.getLogger()
    for handler in root.handlers[:]:
        if isinstance(handler, logging.handlers.RotatingFileHandler):
            handler.close()
            root.removeHandler(handler)
    file_handler = logging.handlers.RotatingFileHandler(
        new_dir / "app.log",
        maxBytes=config.log_max_bytes,
        backupCount=config.log_backup_count,
    )
    file_handler.setFormatter(
        structlog.stdlib.ProcessorFormatter(
            processor=structlog.processors.JSONRenderer(),
        )
    )
    root.addHandler(file_handler)


def _resolve_against(path: Path, base: Path) -> Path:
    """Return *path* unchanged if absolute, otherwise resolve it against *base*."""
    return path if path.is_absolute() else base / path


def _configure_logging(config: TetherConfig, *, log_dir: Path | None = None) -> None:
    """Set up structlog with console output and optional rotating JSON file handler."""
    shared_processors: list[structlog.types.Processor] = [
        structlog.contextvars.merge_contextvars,
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.stdlib.ProcessorFormatter.wrap_for_formatter,
    ]

    root_logger = logging.getLogger()
    root_logger.setLevel(config.log_level)
    root_logger.handlers.clear()

    # Console handler — colored dev-friendly output
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(
        structlog.stdlib.ProcessorFormatter(
            processor=structlog.dev.ConsoleRenderer(),
        )
    )
    root_logger.addHandler(console_handler)

    # File handler — JSON lines for machine parsing
    if log_dir is not None:
        log_dir.mkdir(parents=True, exist_ok=True)
        file_handler = logging.handlers.RotatingFileHandler(
            log_dir / "app.log",
            maxBytes=config.log_max_bytes,
            backupCount=config.log_backup_count,
        )
        file_handler.setFormatter(
            structlog.stdlib.ProcessorFormatter(
                processor=structlog.processors.JSONRenderer(),
            )
        )
        root_logger.addHandler(file_handler)

    # Silence noisy third-party loggers (httpx, telegram, etc.) — they flood
    # the log with low-value HTTP transport chatter at INFO/DEBUG.
    for noisy_logger in ("httpx", "httpcore", "hpack", "telegram", "telegram.ext"):
        logging.getLogger(noisy_logger).setLevel(logging.WARNING)

    structlog.configure(
        processors=shared_processors,
        wrapper_class=structlog.stdlib.BoundLogger,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )


def _load_default_mcp_servers(config: TetherConfig, project_root: Path) -> None:
    """Merge tether's own .mcp.json into config so the agent always has browser tools."""
    mcp_path = project_root / ".mcp.json"
    if not mcp_path.is_file():
        return
    try:
        data = json.loads(mcp_path.read_text())
        file_servers = data.get("mcpServers", {})
        if file_servers:
            # Existing config entries (env overrides) win over file defaults
            config.mcp_servers = {**file_servers, **config.mcp_servers}
    except Exception:
        logger.warning("default_mcp_json_read_failed", path=str(mcp_path))


def build_engine(
    config: TetherConfig | None = None,
    connector: BaseConnector | None = None,
    plugins: list[TetherPlugin] | None = None,
) -> Engine:
    if config is None:
        config = TetherConfig()  # type: ignore[call-arg]  # pydantic-settings loads from env

    # Resolve relative paths against the first approved directory
    project_base = config.approved_directories[0]

    audit_is_pinned = config.audit_log_path.is_absolute()
    storage_is_pinned = config.storage_path.is_absolute()
    log_dir_is_pinned = config.log_dir is not None and config.log_dir.is_absolute()

    resolved_audit = _resolve_against(config.audit_log_path, project_base)
    resolved_storage = _resolve_against(config.storage_path, project_base)
    resolved_log_dir = (
        _resolve_against(config.log_dir, project_base)
        if config.log_dir is not None
        else None
    )

    ensure_tether_dir(project_base)

    _configure_logging(config, log_dir=resolved_log_dir)

    tether_root = Path(__file__).resolve().parent.parent
    _load_default_mcp_servers(config, tether_root)

    if config.workspace_config_root is None:
        config.workspace_config_root = tether_root

    logger.info(
        "engine_building",
        storage_backend=config.storage_backend,
        has_connector=connector is not None,
        policy_count=len(config.policy_files),
        log_level=config.log_level,
        approved_directories=[str(d) for d in config.approved_directories],
    )

    # Session management store — fixed at tether root, never switches with /dir
    ensure_tether_dir(tether_root)
    session_db_path = tether_root / ".tether" / "sessions.db"

    session_store: SessionStore
    if config.storage_backend == "sqlite":
        session_store = SqliteSessionStore(session_db_path)
    else:
        session_store = MemorySessionStore()

    # Per-project message store — switches with /dir
    message_store: MessageStore | None = None
    if config.storage_backend == "sqlite":
        message_store = SqliteSessionStore(resolved_storage)

    session_manager = SessionManager(store=session_store)
    agent = ClaudeCodeAgent(config)
    event_bus = EventBus()

    # Safety components
    policy_paths = list(config.policy_files)
    if not policy_paths:
        policies_dir = Path(__file__).parent / "policies"
        default_policy = policies_dir / "default.yaml"
        dev_tools_policy = policies_dir / "dev-tools.yaml"
        if default_policy.exists():
            policy_paths = [default_policy]
        if dev_tools_policy.exists():
            policy_paths.append(dev_tools_policy)

    policy_engine = PolicyEngine(policy_paths) if policy_paths else None
    sandbox = SandboxEnforcer(
        [*config.approved_directories, Path.home() / ".claude" / "plans"]
    )
    audit = AuditLogger(resolved_audit)

    approval_coordinator = None
    interaction_coordinator = None
    if connector:
        approval_coordinator = ApprovalCoordinator(connector, config)
        interaction_coordinator = InteractionCoordinator(connector, config, event_bus)

    # Plugins
    registry = PluginRegistry()
    registry.register(AuditPlugin(audit))
    registry.register(BrowserToolsPlugin())
    registry.register(TestRunnerPlugin())
    registry.register(MergeResolverPlugin())
    for plugin in plugins or []:
        registry.register(plugin)

    # Middleware
    middleware_chain = MiddlewareChain()
    if config.allowed_user_ids:
        middleware_chain.add(AuthMiddleware(config.allowed_user_ids))
    if config.rate_limit_rpm > 0:
        middleware_chain.add(
            RateLimitMiddleware(config.rate_limit_rpm, config.rate_limit_burst)
        )

    # Git command handler
    git_handler = None
    if connector:
        git_handler = GitCommandHandler(
            service=GitService(),
            connector=connector,
            sandbox=sandbox,
            audit=audit,
            event_bus=event_bus,
        )

    logger.info(
        "engine_built",
        has_auth=bool(config.allowed_user_ids),
        has_rate_limit=config.rate_limit_rpm > 0,
        plugin_count=len(registry.plugins),
        streaming=config.streaming_enabled,
    )

    return Engine(
        connector=connector,
        agent=agent,
        config=config,
        session_manager=session_manager,
        policy_engine=policy_engine,
        sandbox=sandbox,
        audit=audit,
        approval_coordinator=approval_coordinator,
        interaction_coordinator=interaction_coordinator,
        event_bus=event_bus,
        plugin_registry=registry,
        middleware_chain=middleware_chain,
        store=session_store,
        message_store=message_store,
        git_handler=git_handler,
        audit_path_pinned=audit_is_pinned,
        storage_path_pinned=storage_is_pinned,
        audit_path_template=config.audit_log_path,
        storage_path_template=config.storage_path,
        log_dir_pinned=log_dir_is_pinned,
        log_dir_template=config.log_dir,
    )
